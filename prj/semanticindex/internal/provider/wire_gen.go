// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package provider

import (
	"context"
	"github.com/elastic/go-elasticsearch/v8"
	"github.com/minio/minio-go/v7"
	"github.com/nats-io/nats.go"
	"github.com/zuzuka28/simreport/lib/elasticutil"
	"github.com/zuzuka28/simreport/lib/httpinstumentation"
	"github.com/zuzuka28/simreport/lib/minioutil"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/config"
	server2 "github.com/zuzuka28/simreport/prj/semanticindex/internal/handler/nats/event"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/handler/nats/event/handler/indexer"
	semanticindex3 "github.com/zuzuka28/simreport/prj/semanticindex/internal/handler/nats/micro/handler/semanticindex"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/handler/nats/micro/server"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/metrics"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/model"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/repository/document"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/repository/filestorage"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/repository/semanticindex"
	"github.com/zuzuka28/simreport/prj/semanticindex/internal/repository/vectorizer"
	document2 "github.com/zuzuka28/simreport/prj/semanticindex/internal/service/document"
	semanticindex2 "github.com/zuzuka28/simreport/prj/semanticindex/internal/service/semanticindex"
	vectorizer2 "github.com/zuzuka28/simreport/prj/semanticindex/internal/service/vectorizer"
	"net"
	"net/http"
	"sync"
	"time"
)

// Injectors from wire.go:

func InitElastic(contextContext context.Context, configConfig *config.Config) (*elasticsearch.Client, error) {
	elasticutilConfig := configConfig.Elastic
	client, err := elasticutil.NewClientWithStartup(contextContext, elasticutilConfig)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func InitFilestorageRepository(client *minio.Client, configConfig *config.Config, metricsMetrics *metrics.Metrics) (*filestorage.Repository, error) {
	repository := filestorage.NewRepository(client, metricsMetrics)
	return repository, nil
}

func InitDocumentRepository(conn *nats.Conn, metricsMetrics *metrics.Metrics) (*document.Repository, error) {
	repository := document.NewRepository(conn, metricsMetrics)
	return repository, nil
}

func InitVectorizerRepository(configConfig *config.Config, metricsMetrics *metrics.Metrics) (*vectorizer.Repository, error) {
	opts := configConfig.VectorizerRepo
	repository, err := vectorizer.NewRepository(opts, metricsMetrics)
	if err != nil {
		return nil, err
	}
	return repository, nil
}

func InitDocumentService(repository *document.Repository) (*document2.Service, error) {
	service := document2.NewService(repository)
	return service, nil
}

func InitSemanticIndexRepository(client *elasticsearch.Client, configConfig *config.Config, metricsMetrics *metrics.Metrics) (*semanticindex.Repository, error) {
	opts := configConfig.SemanticRepo
	repository, err := semanticindex.NewRepository(opts, client, metricsMetrics)
	if err != nil {
		return nil, err
	}
	return repository, nil
}

func InitVectorizerService(configConfig *config.Config, repository *vectorizer.Repository) (*vectorizer2.Service, error) {
	service := vectorizer2.NewService(repository)
	return service, nil
}

func InitSemanticIndexService(repository *semanticindex.Repository, service *vectorizer2.Service) (*semanticindex2.Service, error) {
	semanticindexService := semanticindex2.NewService(repository, service)
	return semanticindexService, nil
}

func InitSemanticHandler(service *semanticindex2.Service, documentService *document2.Service, repository *filestorage.Repository) (*semanticindex3.Handler, error) {
	handler := semanticindex3.NewHandler(service, documentService, repository)
	return handler, nil
}

func InitIndexerHandler(service *semanticindex2.Service, documentService *document2.Service, repository *filestorage.Repository) (*indexer.Handler, error) {
	handler := indexer.NewHandler(service, documentService, repository)
	return handler, nil
}

func InitNatsMicroAPI(contextContext context.Context, configConfig *config.Config, metricsMetrics *metrics.Metrics) (*server.Server, error) {
	conn, err := ProvideNats(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	client, err := InitElastic(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	repository, err := InitSemanticIndexRepository(client, configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	vectorizerRepository, err := InitVectorizerRepository(configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	service, err := InitVectorizerService(configConfig, vectorizerRepository)
	if err != nil {
		return nil, err
	}
	semanticindexService, err := InitSemanticIndexService(repository, service)
	if err != nil {
		return nil, err
	}
	documentRepository, err := InitDocumentRepository(conn, metricsMetrics)
	if err != nil {
		return nil, err
	}
	documentService, err := InitDocumentService(documentRepository)
	if err != nil {
		return nil, err
	}
	minioClient, err := ProvideS3(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	filestorageRepository, err := InitFilestorageRepository(minioClient, configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	handler, err := InitSemanticHandler(semanticindexService, documentService, filestorageRepository)
	if err != nil {
		return nil, err
	}
	serverServer := server.NewServer(conn, handler, metricsMetrics)
	return serverServer, nil
}

func InitNatsEventAPI(contextContext context.Context, configConfig *config.Config, metricsMetrics *metrics.Metrics) (*server2.Server, error) {
	conn, err := ProvideNats(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	client, err := InitElastic(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	repository, err := InitSemanticIndexRepository(client, configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	vectorizerRepository, err := InitVectorizerRepository(configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	service, err := InitVectorizerService(configConfig, vectorizerRepository)
	if err != nil {
		return nil, err
	}
	semanticindexService, err := InitSemanticIndexService(repository, service)
	if err != nil {
		return nil, err
	}
	documentRepository, err := InitDocumentRepository(conn, metricsMetrics)
	if err != nil {
		return nil, err
	}
	documentService, err := InitDocumentService(documentRepository)
	if err != nil {
		return nil, err
	}
	minioClient, err := ProvideS3(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	filestorageRepository, err := InitFilestorageRepository(minioClient, configConfig, metricsMetrics)
	if err != nil {
		return nil, err
	}
	handler, err := InitIndexerHandler(semanticindexService, documentService, filestorageRepository)
	if err != nil {
		return nil, err
	}
	serverServer := server2.NewServer(conn, handler)
	return serverServer, nil
}

// wire.go:

func ProvideMetrics() *metrics.Metrics {
	return metrics.New()
}

func ProvideConfig(path string) (*config.Config, error) {
	cfg, err := config.New(path)
	if err != nil {
		return nil, err
	}

	defaultTransportDialContext := func(
		dialer *net.Dialer,
	) func(context.Context, string, string) (net.Conn, error) {
		return dialer.DialContext
	}

	transport := &httpinstumentation.InstumentedTransport{
		Transport: &http.Transport{
			Proxy: http.ProxyFromEnvironment,
			DialContext: defaultTransportDialContext(&net.Dialer{
				Timeout:   30 * time.Second,
				KeepAlive: 30 * time.Second,
			}),
			ForceAttemptHTTP2:     true,
			MaxIdleConns:          100,
			IdleConnTimeout:       90 * time.Second,
			TLSHandshakeTimeout:   10 * time.Second,
			ExpectContinueTimeout: 1 * time.Second,
		},
		ExtractAttrs: func(ctx context.Context) []any {
			return []any{"request_id", ctx.Value(model.RequestIDKey)}
		},
		LogRequestBody:  true,
		LogResponseBody: false,
	}

	cfg.Elastic.Transport = transport
	cfg.S3.Transport = transport

	return cfg, nil
}

//nolint:gochecknoglobals
var (
	natsCli     *nats.Conn
	natsCliOnce sync.Once
)

func ProvideNats(
	_ context.Context,
	cfg *config.Config,
) (*nats.Conn, error) {
	var err error

	natsCliOnce.Do(func() {
		natsCli, err = nats.Connect(cfg.Nats)
	})

	return natsCli, err
}

//nolint:gochecknoglobals
var (
	s3Cli     *minio.Client
	s3CliOnce sync.Once
)

func ProvideS3(
	ctx context.Context,
	cfg *config.Config,
) (*minio.Client, error) {
	var err error

	s3CliOnce.Do(func() {
		s3Cli, err = minioutil.NewClientWithStartup(ctx, cfg.S3)
	})

	return s3Cli, err
}
