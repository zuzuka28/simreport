package generator

const serviceTmpl = `
// Code generated by protoc-gen-natsmicro. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/micro"
	"google.golang.org/protobuf/proto"
)

type Handler func(ctx context.Context, req micro.Request)

type ErrorHandler func(ctx context.Context, msg micro.Request, err error)

type Middleware func(Handler) Handler

{{ range .Services }}
// {{ .Name }}ServerInterface is the server API for {{ .Name }} service.
type {{ .Name }}ServerInterface interface {
    {{- range .Methods }}
    {{ .Name }}(context.Context, *{{ .InputType }}) (*{{ .OutputType }}, error)
    {{- end }}
    mustEmbedUnimplementedGreeterServer()
}

type Unimplemented{{ .Name }}Server struct{}

{{- range .Methods }}
func (Unimplemented{{ .Reciever }}Server) {{ .Name }}(context.Context, *{{ .InputType }}) (*{{ .OutputType }}, error) {
	return nil, errors.New("method {{ .Name }} not implemented")
}
{{- end }}

func (Unimplemented{{ .Name }}Server) mustEmbedUnimplemented{{ .Name }}Server() {}

func (Unimplemented{{ .Name }}Server) testEmbeddedByValue() {}

type Unsafe{{ .Name }}Server interface {
	mustEmbedUnimplementedGreeterServer()
}

type {{ .Name }}ServerConfig struct {
	micro.Config
	RequestTimeout              time.Duration
	Middleware                  Middleware
	RequestErrorHandler         ErrorHandler
	ResponseErrorHandler        ErrorHandler
}

type {{ .Name }}Server struct {
    nc     *nats.Conn
    impl   {{ .Name }}ServerInterface
    cfg    {{ .Name }}ServerConfig
    done   chan struct{}

    requestErrorHandlerFunc     ErrorHandler
    responseErrorHandlerFunc    ErrorHandler
}

// New{{ .Name }}Server  creates a new NATS microservice server.
func New{{ .Name }}Server(
    cfg {{ .Name }}ServerConfig,
    nc *nats.Conn,
    impl {{ .Name }}ServerInterface,
) (*{{ .Name }}Server) {
	if t, ok := impl.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}

    if cfg.RequestTimeout == 0 {
        cfg.RequestTimeout = time.Second * 60
    }

    return &{{ .Name }}Server{
        nc: nc,
        impl:   impl,
        cfg:    cfg,
        done:   make(chan struct{}),
        requestErrorHandlerFunc: func(_ context.Context, req micro.Request, _ error) {
            req.Error("500", "unproccessable request", nil, nil)
        },
        responseErrorHandlerFunc: func(_ context.Context, req micro.Request, _ error) {
            req.Error("500", "internal server error", nil, nil)
        },
    }
}

// Start starts the microservice and blocking until application context done.
func (s *{{ .Name }}Server) Start(ctx context.Context) error {
    srv, err := micro.AddService(s.nc, s.cfg.Config)
    if err != nil {
        return fmt.Errorf("failed to start microservice: %w", err)
    }

    defer srv.Stop()

    group := srv.AddGroup(s.cfg.Config.Name)

    // Register handlers
    {{- range .Methods }}
    if err := group.AddEndpoint("{{ snakecase .Name }}", s.toMicroHandler(s.handle{{ .Name }})); err != nil {
        return fmt.Errorf("failed to add endpoint {{ .Name }}: %w", err)
    }
    {{- end }}

    select {
    case <-ctx.Done():
        return ctx.Err()
    case <-s.done:
        return nil
    }
}

func (s *{{ .Name }}Server) Stop() error {
    s.done<-struct{}{}
    return nil
}

func (s *{{ .Name }}Server) toMicroHandler(h Handler) micro.HandlerFunc {
	return func(req micro.Request) {
	    ctx, cancel := context.WithTimeout(context.Background(), s.cfg.RequestTimeout)
	    defer cancel()

	    if s.cfg.Middleware != nil {
            h = s.cfg.Middleware(h)
	    }

	    h(ctx, req)
	}
}

{{ range .Methods }}
func (s *{{ .Reciever }}Server) handle{{ .Name }}(
    ctx context.Context,
    req micro.Request,
) {
	msg := new({{ .InputType }})

	if err := proto.Unmarshal(req.Data(), msg); err != nil {
		s.requestErrorHandlerFunc(ctx, req, err)
		return
	}

	res, err := s.impl.{{ .Name }}(ctx, msg)
	if err != nil {
		s.responseErrorHandlerFunc(ctx, req, err)
		return
	}

	resp, err := proto.Marshal(res)
	if err != nil {
		s.responseErrorHandlerFunc(ctx, req, err)
		return
	}

	req.Respond(resp)
}
{{ end }}

type {{ .Name }}ClientConfig struct {
	MicroSubject string
}

// {{ .Name }}Client is the client API for {{ .Name }} service.
type {{ .Name }}Client struct {
    nc     *nats.Conn
    cfg    {{ .Name }}ClientConfig
}

// New{{ .Name }}Client creates a new NATS microservice client.
func New{{ .Name }}Client(
    cfg {{ .Name }}ClientConfig,
    nc *nats.Conn,
) *{{ .Name }}Client {
    return &{{ .Name }}Client{nc: nc, cfg: cfg}
}

{{ range .Methods }}
func (c *{{ .Reciever }}Client) {{ .Name }}(
    ctx context.Context,
    req *{{ .InputType }},
) (*{{ .OutputType }}, error) {
    resp := new({{ .OutputType }})

    data, err := proto.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    msg, err := c.nc.RequestWithContext(ctx, c.cfg.MicroSubject+".{{ snakecase .Name }}", data)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }

    if err := proto.Unmarshal(msg.Data, resp); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    return resp, nil
}
{{ end }}
{{ end }}
`
