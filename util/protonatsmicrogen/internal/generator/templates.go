package generator

const serviceTmpl = `
// Code generated by protoc-gen-natsmicro. DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/micro"
	"github.com/prometheus/client_golang/prometheus"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/proto"
)

const requestTimeout = time.Second * 60

var (
    requestCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "service_requests_total",
            Help: "Total number of requests processed by the service",
        },
        []string{"service", "method"},
    )
)

{{ range .Services }}
// {{ .Name }}Server is the server API for {{ .Name }} service.
type {{ .Name }}Server interface {
    {{- range .Methods }}
    {{ .Name }}(context.Context, *{{ .InputType }}) (*{{ .OutputType }}, error)
    {{- end }}
}

type {{ lower .Name }}Server struct {
    srv    micro.Service
    impl   {{ .Name }}Server
    tr     trace.Tracer
}

// New{{ .Name }}Server creates a new NATS microservice server
func New{{ .Name }}Server(
    cfg micro.Config,
    nc *nats.Conn,
    impl {{ .Name }}Server,
) (*{{ lower .Name }}Server, error) {
    srv, err := micro.AddService(nc, cfg)
    if err != nil {
        return nil, fmt.Errorf("failed to create microservice: %w", err)
    }

    tr := otel.Tracer("{{ .Name }}")

    s := &{{ lower .Name }}Server{
        srv:    srv,
        impl:   impl,
        tr: tr,
    }

    // Register handlers
    {{- range .Methods }}
    if err := srv.AddEndpoint(cfg.Name+".{{ lower .Name }}", micro.HandlerFunc(s.handle{{ .Name }})); err != nil {
        return nil, fmt.Errorf("failed to add endpoint {{ .Name }}: %w", err)
    }
    {{- end }}

    return s, nil
}

// Stop stops the microservice
func (s *{{ lower .Name }}Server) Stop() error {
    return s.srv.Stop()
}

{{ range .Methods }}
func (s *{{ lower .Reciever }}Server) handle{{ .Name }}(req micro.Request) {
	ctx, cancel := context.WithTimeout(context.Background(), requestCounter)
	defer cancel()

	ctx, span := s.tr.Start(ctx, "{{ .Name }}")
	defer span.End()

    requestCounter.WithLabelValues("{{ lower .Name }}", "{{ .Name }}").Inc()

	msg := new({{ .InputType }})

	if err := proto.Unmarshal(req.Data(), msg); err != nil {
		req.Error("500", "unproccessable request", nil, nil)
		return
	}

	res, err := s.impl.{{ .Name }}(ctx, msg)
	if err != nil {
		req.Error("500", "server error", nil, nil)
		return
	}

	resp, err := proto.Marshal(res)
	if err != nil {
		req.Error("500", "server error", nil, nil)
		return
	}

	req.Respond(resp)
}
{{ end }}

// {{ .Name }}Client is the client API for {{ .Name }} service.
type {{ .Name }}Client struct {
    nc     *nats.Conn
    tr     trace.Tracer
}

// New{{ .Name }}Client creates a new NATS microservice client
func New{{ .Name }}Client(nc *nats.Conn) *{{ .Name }}Client {
    tr := otel.Tracer("{{ .Name }}")
    return &{{ .Name }}Client{nc: nc, tr: tr}
}

{{ range .Methods }}
func (c *{{ .Reciever }}Client) {{ .Name }}(
    ctx context.Context,
    req *{{ .InputType }},
) (*{{ .OutputType }}, error) {
    ctx, span := c.tr.Start(ctx, "{{ .Name }}")
    defer span.End()

    resp := new({{ .OutputType }})

    data, err := proto.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    msg, err := c.nc.RequestWithContext(ctx, "{{ lower .Reciever }}.{{ lower .Name }}", data)
    if err != nil {
        return nil, fmt.Errorf("failed to send request: %w", err)
    }

    if err := proto.Unmarshal(msg.Data, resp); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    return resp, nil
}
{{ end }}
{{ end }}
`
