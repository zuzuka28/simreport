// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package provider

import (
	"context"
	"github.com/elastic/go-elasticsearch/v8"
	"github.com/minio/minio-go/v7"
	"io"
	"os"
	"simrep/api/amqp/asyncnotify/consumer"
	"simrep/api/amqp/asyncnotify/handler/documentsaved"
	"simrep/api/amqp/asyncnotify/handler/filesaved"
	"simrep/api/amqp/asyncnotify/producer"
	"simrep/api/rest/server"
	analyze3 "simrep/api/rest/server/handler/analyze"
	document3 "simrep/api/rest/server/handler/document"
	anysave1 "simrep/api/rest/server/handler/anysave"
	"simrep/internal/config"
	"simrep/internal/model"
	"simrep/internal/repository/analyze"
	"simrep/internal/repository/anysave"
	"simrep/internal/repository/document"
	analyze2 "simrep/internal/service/analyze"
	anysave2 "simrep/internal/service/anysave"
	document2 "simrep/internal/service/document"
	"simrep/internal/service/vectorizer"
	"simrep/pkg/elasticutil"
	"simrep/pkg/minioutil"
	"simrep/pkg/rabbitmq"
	"simrep/pkg/vectorizerclient"
)

// Injectors from wire.go:

func InitConfig(path string) (*config.Config, error) {
	configConfig, err := config.New(path)
	if err != nil {
		return nil, err
	}
	return configConfig, nil
}

func InitElastic(contextContext context.Context, configConfig *config.Config) (*elasticsearch.Client, error) {
	elasticutilConfig := configConfig.Elastic
	client, err := elasticutil.NewClientWithStartup(contextContext, elasticutilConfig)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func InitS3(contextContext context.Context, configConfig *config.Config) (*minio.Client, error) {
	minioutilConfig := configConfig.S3
	client, err := minioutil.NewClientWithStartup(contextContext, minioutilConfig)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func InitVectorizerClient(configConfig *config.Config) (*client.ClientWithResponses, error) {
	string2 := configConfig.VectorizerService
	v := _wireValue
	clientWithResponses, err := client.NewClientWithResponses(string2, v...)
	if err != nil {
		return nil, err
	}
	return clientWithResponses, nil
}

var (
	_wireValue = []client.ClientOption(nil)
)

func InitRabbitNotifyFileSavedPublisher(configConfig *config.Config) (*rabbitmq.Producer, error) {
	producerConfig := configConfig.NotifyFileSavedProducer
	producer, err := rabbitmq.NewProducer(producerConfig)
	if err != nil {
		return nil, err
	}
	return producer, nil
}

func InitRabbitNotifyDocumentSavedPublisher(configConfig *config.Config) (*rabbitmq.Producer, error) {
	producerConfig := configConfig.NotifyDocumentSavedProducer
	producer, err := rabbitmq.NewProducer(producerConfig)
	if err != nil {
		return nil, err
	}
	return producer, nil
}

func InitRabbitNotifyDocumentAnalyzedPublisher(configConfig *config.Config) (*rabbitmq.Producer, error) {
	producerConfig := configConfig.NotifyDocumentAnalyzedProducer
	producer, err := rabbitmq.NewProducer(producerConfig)
	if err != nil {
		return nil, err
	}
	return producer, nil
}

func InitRabbitNotifyFileSavedConsumer(configConfig *config.Config) (*rabbitmq.Consumer, error) {
	consumerConfig := configConfig.NotifyFileSavedConsumer
	consumer, err := rabbitmq.NewConsumer(consumerConfig)
	if err != nil {
		return nil, err
	}
	return consumer, nil
}

func InitRabbitNotifyDocumentSavedConsumer(configConfig *config.Config) (*rabbitmq.Consumer, error) {
	consumerConfig := configConfig.NotifyDocumentSavedConsumer
	consumer, err := rabbitmq.NewConsumer(consumerConfig)
	if err != nil {
		return nil, err
	}
	return consumer, nil
}

func InitRabbitNotifyDocumentAnalyzedConsumer(configConfig *config.Config) (*rabbitmq.Consumer, error) {
	consumerConfig := configConfig.NotifyDocumentAnalyzedConsumer
	consumer, err := rabbitmq.NewConsumer(consumerConfig)
	if err != nil {
		return nil, err
	}
	return consumer, nil
}

func InitNotifyFileSavedProducer(configConfig *config.Config) (*producer.Producer, error) {
	rabbitmqProducer, err := InitRabbitNotifyFileSavedPublisher(configConfig)
	if err != nil {
		return nil, err
	}
	producerProducer := producer.New(rabbitmqProducer)
	return producerProducer, nil
}

func InitNotifyDocumentSavedProducer(configConfig *config.Config) (*producer.Producer, error) {
	rabbitmqProducer, err := InitRabbitNotifyDocumentSavedPublisher(configConfig)
	if err != nil {
		return nil, err
	}
	producerProducer := producer.New(rabbitmqProducer)
	return producerProducer, nil
}

func InitNotifyDocumentAnalyzedProducer(configConfig *config.Config) (*producer.Producer, error) {
	rabbitmqProducer, err := InitRabbitNotifyDocumentAnalyzedPublisher(configConfig)
	if err != nil {
		return nil, err
	}
	producerProducer := producer.New(rabbitmqProducer)
	return producerProducer, nil
}

func InitDocumentFileRepository(minioClient *minio.Client, configConfig *config.Config) (*anysave.Repository, error) {
	repository := anysave.NewRepository(minioClient)
	return repository, nil
}

func InitDocumentRepository(elasticsearchClient *elasticsearch.Client, configConfig *config.Config) (*document.Repository, error) {
	opts := configConfig.DocumentRepo
	repository, err := document.NewRepository(opts, elasticsearchClient)
	if err != nil {
		return nil, err
	}
	return repository, nil
}

func InitAnalyzedDocumentRepository(elasticsearchClient *elasticsearch.Client, configConfig *config.Config) (*analyze.Repository, error) {
	opts := configConfig.AnalyzedDocumentRepo
	repository, err := analyze.NewRepository(opts, elasticsearchClient)
	if err != nil {
		return nil, err
	}
	return repository, nil
}

func InitVectorizerService(clientWithResponses *client.ClientWithResponses) (*vectorizer.Service, error) {
	service := vectorizer.NewService(clientWithResponses)
	return service, nil
}

func InitAnalyzeService(configConfig *config.Config, service *vectorizer.Service, repository *analyze.Repository) (*analyze2.Service, error) {
	producerProducer, err := InitNotifyDocumentAnalyzedProducer(configConfig)
	if err != nil {
		return nil, err
	}
	analyzeService := analyze2.NewService(repository, service, producerProducer)
	return analyzeService, nil
}

func InitAnysaveService(minioClient *minio.Client, configConfig *config.Config) (*anysave2.Service, error) {
	producerProducer, err := InitNotifyFileSavedProducer(configConfig)
	if err != nil {
		return nil, err
	}
	opts := ProvideAnysaveServiceOpts(producerProducer)
	repository, err := InitDocumentFileRepository(minioClient, configConfig)
	if err != nil {
		return nil, err
	}
	service := anysave2.NewService(opts, repository)
	return service, nil
}

func InitDocumentService(configConfig *config.Config, service *anysave2.Service, repository *document.Repository) (*document2.Service, error) {
	producerProducer, err := InitNotifyDocumentSavedProducer(configConfig)
	if err != nil {
		return nil, err
	}
	opts := ProvideDocumentServiceOpts(producerProducer)
	documentService := document2.NewService(opts, repository, service)
	return documentService, nil
}

func InitDocumentHandler(service *document2.Service) *document3.Handler {
	handler := document3.NewHandler(service)
	return handler
}

func InitFileHandler(service *anysave2.Service) *anysave1.Handler {
	handler := anysave1.NewHandler(service)
	return handler
}

func InitAnalyzeHandler(service *document2.Service, analyzeService *analyze2.Service) *analyze3.Handler {
	handler := analyze3.NewHandler(analyzeService, service)
	return handler
}

func InitRestAPI(contextContext context.Context, configConfig *config.Config) (*server.Server, error) {
	int2 := configConfig.Port
	v, err := ProvideSpec()
	if err != nil {
		return nil, err
	}
	minioClient, err := InitS3(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	service, err := InitAnysaveService(minioClient, configConfig)
	if err != nil {
		return nil, err
	}
	elasticsearchClient, err := InitElastic(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	repository, err := InitDocumentRepository(elasticsearchClient, configConfig)
	if err != nil {
		return nil, err
	}
	documentService, err := InitDocumentService(configConfig, service, repository)
	if err != nil {
		return nil, err
	}
	handler := InitDocumentHandler(documentService)
	clientWithResponses, err := InitVectorizerClient(configConfig)
	if err != nil {
		return nil, err
	}
	vectorizerService, err := InitVectorizerService(clientWithResponses)
	if err != nil {
		return nil, err
	}
	analyzeRepository, err := InitAnalyzedDocumentRepository(elasticsearchClient, configConfig)
	if err != nil {
		return nil, err
	}
	analyzeService, err := InitAnalyzeService(configConfig, vectorizerService, analyzeRepository)
	if err != nil {
		return nil, err
	}
	analyzeHandler := InitAnalyzeHandler(documentService, analyzeService)
	fileHandler := InitFileHandler(service)
	opts := server.Opts{
		Port:            int2,
		Spec:            v,
		DocumentHandler: handler,
		AnalyzeHandler:  analyzeHandler,
		FileHandler:     fileHandler,
	}
	serverServer, err := server.New(opts)
	if err != nil {
		return nil, err
	}
	return serverServer, nil
}

func InitAsyncFileSavedHandler(service *anysave2.Service, documentService *document2.Service) *filesaved.Handler {
	handler := filesaved.NewHandler(service, documentService)
	return handler
}

func InitAsyncDocumentSavedHandler(service *document2.Service, analyzeService *analyze2.Service) *documentsaved.Handler {
	handler := documentsaved.NewHandler(service, analyzeService)
	return handler
}

func InitAsyncDocumentParsing(contextContext context.Context, configConfig *config.Config) (*consumer.Consumer, error) {
	rabbitmqConsumer, err := InitRabbitNotifyFileSavedConsumer(configConfig)
	if err != nil {
		return nil, err
	}
	minioClient, err := InitS3(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	service, err := InitAnysaveService(minioClient, configConfig)
	if err != nil {
		return nil, err
	}
	elasticsearchClient, err := InitElastic(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	repository, err := InitDocumentRepository(elasticsearchClient, configConfig)
	if err != nil {
		return nil, err
	}
	documentService, err := InitDocumentService(configConfig, service, repository)
	if err != nil {
		return nil, err
	}
	handler := InitAsyncFileSavedHandler(service, documentService)
	consumerConsumer := consumer.New(rabbitmqConsumer, handler)
	return consumerConsumer, nil
}

func InitAsyncDocumentAnalysis(contextContext context.Context, configConfig *config.Config) (*consumer.Consumer, error) {
	rabbitmqConsumer, err := InitRabbitNotifyDocumentSavedConsumer(configConfig)
	if err != nil {
		return nil, err
	}
	minioClient, err := InitS3(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	service, err := InitAnysaveService(minioClient, configConfig)
	if err != nil {
		return nil, err
	}
	elasticsearchClient, err := InitElastic(contextContext, configConfig)
	if err != nil {
		return nil, err
	}
	repository, err := InitDocumentRepository(elasticsearchClient, configConfig)
	if err != nil {
		return nil, err
	}
	documentService, err := InitDocumentService(configConfig, service, repository)
	if err != nil {
		return nil, err
	}
	clientWithResponses, err := InitVectorizerClient(configConfig)
	if err != nil {
		return nil, err
	}
	vectorizerService, err := InitVectorizerService(clientWithResponses)
	if err != nil {
		return nil, err
	}
	analyzeRepository, err := InitAnalyzedDocumentRepository(elasticsearchClient, configConfig)
	if err != nil {
		return nil, err
	}
	analyzeService, err := InitAnalyzeService(configConfig, vectorizerService, analyzeRepository)
	if err != nil {
		return nil, err
	}
	handler := InitAsyncDocumentSavedHandler(documentService, analyzeService)
	consumerConsumer := consumer.New(rabbitmqConsumer, handler)
	return consumerConsumer, nil
}

// wire.go:

func ProvideSpec() ([]byte, error) {
	f, err := os.Open("./api/rest/doc/openapi.yaml")
	if err != nil {
		return nil, err
	}

	spec, err := io.ReadAll(f)
	if err != nil {
		return nil, err
	}

	return spec, nil
}

func ProvideAnysaveServiceOpts(
	p *producer.Producer,
) anysave2.Opts {
	return anysave2.Opts{
		OnSaveAction: func(ctx context.Context, cmd model.FileSaveCommand) error {
			return p.Notify(ctx, cmd.Item.Sha256, model.NotifyActionFileSaved, nil)
		},
	}
}

func ProvideDocumentServiceOpts(
	p *producer.Producer,
) document2.Opts {
	return document2.Opts{
		OnSaveAction: func(ctx context.Context, cmd model.DocumentSaveCommand) error {
			return p.Notify(ctx, cmd.Item.ID, model.NotifyActionDocumentSaved, nil)
		},
	}
}
